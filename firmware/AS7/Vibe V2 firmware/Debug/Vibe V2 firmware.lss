
Vibe V2 firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006dc  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000730  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000730  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000760  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000080  00000000  00000000  0000079c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000cec  00000000  00000000  0000081c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000331  00000000  00000000  00001508  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004d1  00000000  00000000  00001839  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000120  00000000  00000000  00001d0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000335  00000000  00000000  00001e2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e49  00000000  00000000  00002161  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000238  00000000  00000000  00002faa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	18 c0       	rjmp	.+48     	; 0x32 <__ctors_end>
   2:	1f c0       	rjmp	.+62     	; 0x42 <__bad_interrupt>
   4:	cc c0       	rjmp	.+408    	; 0x19e <__vector_2>
   6:	cc c0       	rjmp	.+408    	; 0x1a0 <__vector_3>
   8:	1c c0       	rjmp	.+56     	; 0x42 <__bad_interrupt>
   a:	1b c0       	rjmp	.+54     	; 0x42 <__bad_interrupt>
   c:	1a c0       	rjmp	.+52     	; 0x42 <__bad_interrupt>
   e:	19 c0       	rjmp	.+50     	; 0x42 <__bad_interrupt>
  10:	18 c0       	rjmp	.+48     	; 0x42 <__bad_interrupt>
  12:	17 c0       	rjmp	.+46     	; 0x42 <__bad_interrupt>
  14:	16 c0       	rjmp	.+44     	; 0x42 <__bad_interrupt>
  16:	15 c0       	rjmp	.+42     	; 0x42 <__bad_interrupt>
  18:	14 c0       	rjmp	.+40     	; 0x42 <__bad_interrupt>
  1a:	13 c0       	rjmp	.+38     	; 0x42 <__bad_interrupt>
  1c:	12 c0       	rjmp	.+36     	; 0x42 <__bad_interrupt>
  1e:	11 c0       	rjmp	.+34     	; 0x42 <__bad_interrupt>
  20:	10 c0       	rjmp	.+32     	; 0x42 <__bad_interrupt>

00000022 <__trampolines_end>:
  22:	00 00       	nop
  24:	00 00       	nop
  26:	40 0c       	add	r4, r0
  28:	56 1d       	adc	r21, r6
  2a:	20 23       	and	r18, r16
  2c:	01 20       	and	r0, r1
  2e:	38 63       	ori	r19, 0x38	; 56
  30:	2c 3d       	cpi	r18, 0xDC	; 220

00000032 <__ctors_end>:
  32:	11 24       	eor	r1, r1
  34:	1f be       	out	0x3f, r1	; 63
  36:	cf e5       	ldi	r28, 0x5F	; 95
  38:	d2 e0       	ldi	r29, 0x02	; 2
  3a:	de bf       	out	0x3e, r29	; 62
  3c:	cd bf       	out	0x3d, r28	; 61
  3e:	b1 d0       	rcall	.+354    	; 0x1a2 <main>
  40:	4b c3       	rjmp	.+1686   	; 0x6d8 <_exit>

00000042 <__bad_interrupt>:
  42:	de cf       	rjmp	.-68     	; 0x0 <__vectors>

00000044 <motorInit>:
// Initialize the motor pin. Sets to output mode, which will drive is LOW 
// Call this as soon as possible after reset to keep the mosfet from floating and turning on the motor

void motorInit() {
	
	DDRA |= _BV(5);		// Set pin to output mode. It will already be low because ports default to 0 on reset
  44:	d5 9a       	sbi	0x1a, 5	; 26
  46:	08 95       	ret

00000048 <setMotorPWM>:
// top sets the frequency where PWM frequency = F_CPU/top. The minimum resolution allowed is 2-bit (top set to 0x0003).


void setMotorPWM( uint16_t match , uint16_t top ) {
			
	if (match==0) {			// Special case this because the PWM generator still generates a pulse at 0 duty cycle
  48:	00 97       	sbiw	r24, 0x00	; 0
  4a:	11 f4       	brne	.+4      	; 0x50 <setMotorPWM+0x8>
// Turn the motor completely off- disconnects from PWM generator

void motorOff(void) {

		
	TCCR1A = 0;		// Disconnect Timer1A outputs from pins. "Normal port operation, OC1B disconnected"	
  4c:	1f bc       	out	0x2f, r1	; 47
  4e:	08 95       	ret
		// Clock select clk	I/O/1 (No prescaling)
		
		
		// Assign TOP first to make sure we don't miss the match
		
		OCR1A = top;							// Set TOP. Freq should be IOclk/OCR1A = 16Khz		
  50:	7b bd       	out	0x2b, r23	; 43
  52:	6a bd       	out	0x2a, r22	; 42
		OCR1B = match;		// Set match which sets duty cycle
  54:	99 bd       	out	0x29, r25	; 41
  56:	88 bd       	out	0x28, r24	; 40
		
		
		//			0bxx100000	COM1B		PWM Fast mode, Clear OC1A/OC1B on Compare Match, set OC1A/OC1B at BOTTOM (non-inverting mode)
		//			0bxxxxxx11	WGM[11:10]	Fast PWM, TOP=OCR1A, Update at OCR TOP
	
		TCCR1A =	0b00100011;
  58:	83 e2       	ldi	r24, 0x23	; 35
  5a:	8f bd       	out	0x2f, r24	; 47
	
		//			0b00011000	WGM[13:12]	Fast PWM TOP=OCR1A UPDATE=TOP, Compare output on pin
		//			0b00000001	CS			clk	I/O/1 (No prescaling)
	
		TCCR1B =	0b00011001;
  5c:	89 e1       	ldi	r24, 0x19	; 25
  5e:	8e bd       	out	0x2e, r24	; 46
  60:	08 95       	ret

00000062 <readVccVoltage>:
	// Select ADC inputs
	// bit    76543210 
	// REFS = 00       = Vcc used as Vref
	// MUX  =   100001 = Single ended, 1.1V (Internal Ref) as Vin
	
	ADMUX = 0b00100001;
  62:	81 e2       	ldi	r24, 0x21	; 33
  64:	87 b9       	out	0x07, r24	; 7
	kHz and 200 kHz to get maximum resolution.
	*/	
				
	// Enable ADC, set pre-scaller to /8 which will give a ADC clock of 8mHz/64 = 125kHz
	
	ADCSRA = _BV(ADEN) | _BV(ADPS1) | _BV(ADPS2);
  66:	86 e8       	ldi	r24, 0x86	; 134
  68:	86 b9       	out	0x06, r24	; 6
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  6a:	89 ef       	ldi	r24, 0xF9	; 249
  6c:	90 e0       	ldi	r25, 0x00	; 0
  6e:	01 97       	sbiw	r24, 0x01	; 1
  70:	f1 f7       	brne	.-4      	; 0x6e <readVccVoltage+0xc>
  72:	00 c0       	rjmp	.+0      	; 0x74 <readVccVoltage+0x12>
  74:	00 00       	nop
	/*
		The first conversion after switching voltage source may be inaccurate, and the user is advised to discard this result.
	*/
	
		
	ADCSRA |= _BV(ADSC);				// Start a conversion
  76:	36 9a       	sbi	0x06, 6	; 6


	while( ADCSRA & _BV( ADSC) ) ;		// Wait for 1st conversion to be ready...
  78:	36 99       	sbic	0x06, 6	; 6
  7a:	fe cf       	rjmp	.-4      	; 0x78 <readVccVoltage+0x16>
		When ADCL is read, the ADC Data Register is not updated until ADCH is read.		
	*/
	
	// Note we could have used ADLAR left adjust mode and then only needed to read a single byte here
		
	uint8_t low  = ADCL;
  7c:	64 b1       	in	r22, 0x04	; 4
	uint8_t high = ADCH;
  7e:	85 b1       	in	r24, 0x05	; 5
		Note that the ADC will not automatically be turned off when entering other sleep modes than Idle
		mode and ADC Noise Reduction mode. The user is advised to write zero to ADEN before entering such
		sleep modes to avoid excessive power consumption.
	*/
	
	ADCSRA &= ~_BV( ADEN );			// Disable ADC to save power
  80:	37 98       	cbi	0x06, 7	; 6
	// Note we could have used ADLAR left adjust mode and then only needed to read a single byte here
		
	uint8_t low  = ADCL;
	uint8_t high = ADCH;

	uint16_t adc = (high << 8) | low;		// 0<= result <=1023
  82:	70 e0       	ldi	r23, 0x00	; 0
  84:	78 2b       	or	r23, r24
	//
	// Vcc   =  (1.1v * 1024) / ADC
	// Vcc10 = ((1.1v * 1024) / ADC ) * 10			->convert to 1 decimal fixed point
	// Vcc10 = ((11   * 1024) / ADC )				->simplify to all 16-bit integer math
				
	uint8_t vccx10 = (uint8_t) ( (11 * 1024) / adc); 
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	9c e2       	ldi	r25, 0x2C	; 44
  8a:	6e d2       	rcall	.+1244   	; 0x568 <__udivmodhi4>
  8c:	86 2f       	mov	r24, r22
	
	ADCSRA &= ~_BV( ADEN );			// Disable ADC to save power
	
	return( vccx10 );
	
}
  8e:	08 95       	ret

00000090 <updateMotor>:

// Set the motor to run at the specified duty cycle and frequency
// The duty cycle is specified at 4.2 volts as a value 0-65535. It is adjusted to scale to the actual voltage. 
// Of course if you specify 100% at 4.2v and only 3.8v is available, then it will just give 100% at the current voltage

void updateMotor( uint16_t top, uint16_t normalizedDuty, uint8_t vccx10 ) {
  90:	8f 92       	push	r8
  92:	9f 92       	push	r9
  94:	af 92       	push	r10
  96:	bf 92       	push	r11
  98:	cf 92       	push	r12
  9a:	df 92       	push	r13
  9c:	ef 92       	push	r14
  9e:	ff 92       	push	r15
  a0:	0f 93       	push	r16
  a2:	1f 93       	push	r17
  a4:	cf 93       	push	r28
  a6:	df 93       	push	r29
  a8:	ec 01       	movw	r28, r24
			
	unsigned long voltageAdjustedDuty = (((normalizedDuty * 42UL ) / vccx10) );		// All dutys are normalized to 4.2 volts, so adjust to the current volatge level. Note that is could overflow an uint16 if the voltage is lower than the normal value. 
	
	unsigned long voltageAdjusedMatch = (voltageAdjustedDuty  * top ) / 65535UL;	// Covert the duty that is scaled 0-65535 to a match that is scaled 0-top.
  aa:	6c 01       	movw	r12, r24
  ac:	e1 2c       	mov	r14, r1
  ae:	f1 2c       	mov	r15, r1
// The duty cycle is specified at 4.2 volts as a value 0-65535. It is adjusted to scale to the actual voltage. 
// Of course if you specify 100% at 4.2v and only 3.8v is available, then it will just give 100% at the current voltage

void updateMotor( uint16_t top, uint16_t normalizedDuty, uint8_t vccx10 ) {
			
	unsigned long voltageAdjustedDuty = (((normalizedDuty * 42UL ) / vccx10) );		// All dutys are normalized to 4.2 volts, so adjust to the current volatge level. Note that is could overflow an uint16 if the voltage is lower than the normal value. 
  b0:	8b 01       	movw	r16, r22
  b2:	20 e0       	ldi	r18, 0x00	; 0
  b4:	30 e0       	ldi	r19, 0x00	; 0
  b6:	48 01       	movw	r8, r16
  b8:	59 01       	movw	r10, r18
  ba:	88 0c       	add	r8, r8
  bc:	99 1c       	adc	r9, r9
  be:	aa 1c       	adc	r10, r10
  c0:	bb 1c       	adc	r11, r11
  c2:	88 0c       	add	r8, r8
  c4:	99 1c       	adc	r9, r9
  c6:	aa 1c       	adc	r10, r10
  c8:	bb 1c       	adc	r11, r11
  ca:	d5 01       	movw	r26, r10
  cc:	c4 01       	movw	r24, r8
  ce:	88 0f       	add	r24, r24
  d0:	99 1f       	adc	r25, r25
  d2:	aa 1f       	adc	r26, r26
  d4:	bb 1f       	adc	r27, r27
  d6:	88 0f       	add	r24, r24
  d8:	99 1f       	adc	r25, r25
  da:	aa 1f       	adc	r26, r26
  dc:	bb 1f       	adc	r27, r27
  de:	88 0d       	add	r24, r8
  e0:	99 1d       	adc	r25, r9
  e2:	aa 1d       	adc	r26, r10
  e4:	bb 1d       	adc	r27, r11
  e6:	80 0f       	add	r24, r16
  e8:	91 1f       	adc	r25, r17
  ea:	a2 1f       	adc	r26, r18
  ec:	b3 1f       	adc	r27, r19
  ee:	bc 01       	movw	r22, r24
  f0:	cd 01       	movw	r24, r26
  f2:	66 0f       	add	r22, r22
  f4:	77 1f       	adc	r23, r23
  f6:	88 1f       	adc	r24, r24
  f8:	99 1f       	adc	r25, r25
  fa:	24 2f       	mov	r18, r20
  fc:	30 e0       	ldi	r19, 0x00	; 0
  fe:	40 e0       	ldi	r20, 0x00	; 0
 100:	50 e0       	ldi	r21, 0x00	; 0
 102:	46 d2       	rcall	.+1164   	; 0x590 <__udivmodsi4>
	
	unsigned long voltageAdjusedMatch = (voltageAdjustedDuty  * top ) / 65535UL;	// Covert the duty that is scaled 0-65535 to a match that is scaled 0-top.
 104:	ca 01       	movw	r24, r20
 106:	b9 01       	movw	r22, r18
 108:	a7 01       	movw	r20, r14
 10a:	96 01       	movw	r18, r12
 10c:	65 d2       	rcall	.+1226   	; 0x5d8 <__umulsidi3>
 10e:	62 2f       	mov	r22, r18
 110:	73 2f       	mov	r23, r19
 112:	84 2f       	mov	r24, r20
 114:	95 2f       	mov	r25, r21
 116:	2f ef       	ldi	r18, 0xFF	; 255
 118:	3f ef       	ldi	r19, 0xFF	; 255
 11a:	40 e0       	ldi	r20, 0x00	; 0
 11c:	50 e0       	ldi	r21, 0x00	; 0
 11e:	38 d2       	rcall	.+1136   	; 0x590 <__udivmodsi4>
																					// Match = (duty/65535) * top, but we need to stay integer so switch the order
																					// Keep as a long because it could be bigger than an int due to scaling because of a low voltage
		
	uint16_t match;
	
	if (voltageAdjusedMatch > top ) {		// Battery to low for requested duty, so give it all we've got
 120:	c2 16       	cp	r12, r18
 122:	d3 06       	cpc	r13, r19
 124:	e4 06       	cpc	r14, r20
 126:	f5 06       	cpc	r15, r21
 128:	18 f0       	brcs	.+6      	; 0x130 <updateMotor+0xa0>
		
		match = top; 
		
	} else {
		
		match = (uint16_t) voltageAdjusedMatch;		// We know that adjusted duty will fit into uint_16 here because it is less than top which is a uint16
 12a:	82 2f       	mov	r24, r18
 12c:	93 2f       	mov	r25, r19
 12e:	02 c0       	rjmp	.+4      	; 0x134 <updateMotor+0xa4>
		
	uint16_t match;
	
	if (voltageAdjusedMatch > top ) {		// Battery to low for requested duty, so give it all we've got
		
		match = top; 
 130:	8c 2f       	mov	r24, r28
 132:	9d 2f       	mov	r25, r29
		
		match = (uint16_t) voltageAdjusedMatch;		// We know that adjusted duty will fit into uint_16 here because it is less than top which is a uint16
		
	}
			
	setMotorPWM( match , top  );
 134:	be 01       	movw	r22, r28
 136:	88 df       	rcall	.-240    	; 0x48 <setMotorPWM>

}
 138:	df 91       	pop	r29
 13a:	cf 91       	pop	r28
 13c:	1f 91       	pop	r17
 13e:	0f 91       	pop	r16
 140:	ff 90       	pop	r15
 142:	ef 90       	pop	r14
 144:	df 90       	pop	r13
 146:	cf 90       	pop	r12
 148:	bf 90       	pop	r11
 14a:	af 90       	pop	r10
 14c:	9f 90       	pop	r9
 14e:	8f 90       	pop	r8
 150:	08 95       	ret

00000152 <enableTimer0>:
// Note that this just turns on the timer. For the LEDs to come on, we need to set the control bits to let the compare bits show up on the pins
// Also note that we are running in inverted mode, which means there will be a tiny glitch each cycle at full power (I should have put the LEDs in backwards!)

void enableTimer0() {
		
	TCNT0 = 0;		// Start timer counter at 0;
 152:	12 be       	out	0x32, r1	; 50
	
	TCCR0A = _BV( WGM01) | _BV( WGM00 ) ;	// Mode 3 Fast PWM TOP=0xff, update OCRx at BOTTOM
 154:	83 e0       	ldi	r24, 0x03	; 3
 156:	80 bf       	out	0x30, r24	; 48
		
		//   0bxxxx0xxx	-~WGM02				Mode 3 Fast PWM TOP=0xff, update OCRx at BOTTOM
		//	 0bxxxxx001 CS01				clk/1 prescaler
		//   ===========
	TCCR0B = 0b00000001;	
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	83 bf       	out	0x33, r24	; 51
	
	OCR0A = 0;		// Start with LEDs off
 15c:	16 be       	out	0x36, r1	; 54
	OCR0B = 0;	
 15e:	1c be       	out	0x3c, r1	; 60
 160:	08 95       	ret

00000162 <setWhiteLED>:

// Set brightness of LEDs. 0=off, 255=full on

void setWhiteLED( uint8_t b ) {
	
	if (b==0)	{	// Off
 162:	81 11       	cpse	r24, r1
 164:	05 c0       	rjmp	.+10     	; 0x170 <setWhiteLED+0xe>
		
		WHITE_LED_PORT &= ~_BV(WHITE_LED_BIT);				// Normal port Output to low 			
 166:	c2 98       	cbi	0x18, 2	; 24
		TCCR0A &= ~ ( _BV( COM0A1  ) | _BV( COM0A0 ) );		// Normal port operation, OC0A disconnected (happens to hold true for all modes)
 168:	80 b7       	in	r24, 0x30	; 48
 16a:	8f 73       	andi	r24, 0x3F	; 63
 16c:	80 bf       	out	0x30, r24	; 48
 16e:	08 95       	ret
	
	} else {
		
		b/=16;												// Account for missing current limiting resistor - empirically found
 170:	82 95       	swap	r24
 172:	8f 70       	andi	r24, 0x0F	; 15
		
		OCR0A = ~b;											// Set the compare register	- double buffered so will update at next top	
 174:	80 95       	com	r24
 176:	86 bf       	out	0x36, r24	; 54
		TCCR0A |= ( _BV( COM0A1  ) | _BV( COM0A0 ) );		// Set OC0A on Compare Match, Clear OC0A at BOTTOM (inverting mode)
 178:	80 b7       	in	r24, 0x30	; 48
 17a:	80 6c       	ori	r24, 0xC0	; 192
 17c:	80 bf       	out	0x30, r24	; 48
 17e:	08 95       	ret

00000180 <setRedLED>:
		
}

void setRedLED( uint8_t b ) {
		
	if (b==0)	{	// Off
 180:	81 11       	cpse	r24, r1
 182:	05 c0       	rjmp	.+10     	; 0x18e <setRedLED+0xe>
		
		RED_LED_PORT &= ~_BV(RED_LED_BIT);					// Normal port output to low	
 184:	df 98       	cbi	0x1b, 7	; 27
		TCCR0A &= ~ ( _BV( COM0B1  ) | _BV( COM0B0 ) );		// Normal port operation, OC0B disconnected (happens to hold true for all modes)
 186:	80 b7       	in	r24, 0x30	; 48
 188:	8f 7c       	andi	r24, 0xCF	; 207
 18a:	80 bf       	out	0x30, r24	; 48
 18c:	08 95       	ret
		
	} else {
		
		b/=16;												// Account for missing current limiting resistor - empirically found
 18e:	82 95       	swap	r24
 190:	8f 70       	andi	r24, 0x0F	; 15
		
		OCR0B = ~b;											// Set the compare register	- double buffered so will update at next top	
 192:	80 95       	com	r24
 194:	8c bf       	out	0x3c, r24	; 60
		TCCR0A |= ( _BV( COM0B1  ) | _BV( COM0B0 ) );		// Set OC0B on Compare Match, Clear OC0B at BOTTOM (inverting mode)
 196:	80 b7       	in	r24, 0x30	; 48
 198:	80 63       	ori	r24, 0x30	; 48
 19a:	80 bf       	out	0x30, r24	; 48
 19c:	08 95       	ret

0000019e <__vector_2>:
// Dummy ISRs for the pin change interrupts.
// These will catch and wake on..
// *Change in battery charger status lines
// *Incoming bit on the power port

EMPTY_INTERRUPT( PCINT0_vect );
 19e:	18 95       	reti

000001a0 <__vector_3>:
	// This is a dummy routine. This is here just so the processor has something to do when it wakes up.
	// This will just return back to the main program. 
	// TODO: Figure out how to just put an IRET in the vector table to save time and code space.


EMPTY_INTERRUPT( PCINT1_vect );
 1a0:	18 95       	reti

000001a2 <main>:
	
	
int main(void)
{
	
	motorInit();				// Initialize the motor port to drive the MOSFET low
 1a2:	50 df       	rcall	.-352    	; 0x44 <motorInit>
	
	uint8_t watchDogResetFlag = MCUSR & _BV(WDRF);		/// Save the watchdog flag
 1a4:	c4 b7       	in	r28, 0x34	; 52
	
	MCUSR &= ~ _BV( WDRF );		// Clear the watchdog flag
 1a6:	84 b7       	in	r24, 0x34	; 52
 1a8:	87 7f       	andi	r24, 0xF7	; 247
 1aa:	84 bf       	out	0x34, r24	; 52
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
 1ac:	99 e2       	ldi	r25, 0x29	; 41
 1ae:	88 e1       	ldi	r24, 0x18	; 24
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	f8 94       	cli
 1b4:	a8 95       	wdr
 1b6:	81 bd       	out	0x21, r24	; 33
 1b8:	0f be       	out	0x3f, r0	; 63
 1ba:	91 bd       	out	0x21, r25	; 33
								// "This means that WDE is always set when WDRF is set."
								// IF we left this Set, then we could get watchdogged while sleeping
								
	wdt_enable( WDTO_8S );		// Give ourselves 8 seconds before forced reboot
			
	enableTimer0();				// Initialize the timer that also PWMs the LEDs
 1bc:	ca df       	rcall	.-108    	; 0x152 <enableTimer0>
	
	WHITE_LED_DDR	|= _BV(WHITE_LED_BIT);		// Pin to output
 1be:	ba 9a       	sbi	0x17, 2	; 23
	RED_LED_DDR		|= _BV(RED_LED_BIT);
 1c0:	d7 9a       	sbi	0x1a, 7	; 26

	// Button sense pin setup	
	
	BUTTON_PORT |= _BV(BUTTON_BIT);		// Enable pull-up for button pin
 1c2:	c0 9a       	sbi	0x18, 0	; 24
	
	// Battery Charger status pin setup
	
	EOC_PORT |= _BV(EOC_BIT);				// Activate pull-up
 1c4:	d8 9a       	sbi	0x1b, 0	; 27
	
	CIP_PORT |= _BV( CIP_BIT);				// Activate pull-up
 1c6:	d9 9a       	sbi	0x1b, 1	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1c8:	00 00       	nop
	
	_delay_us(1);							// Give the pull-ups a second to work	
			
	if ( !watchDogResetFlag )		{		// Are we coming out of anything except for a WatchDog reset?
 1ca:	c3 fd       	sbrc	r28, 3
 1cc:	95 c1       	rjmp	.+810    	; 0x4f8 <__stack+0x299>
		// Cold boot, run test mode
				
		// Blink back and forth to show LEDs work and solicit a button press	
		
			
		for(uint8_t i=0;i<100 && !BUTTON_STATE_DOWN(); i++ ) {
 1ce:	b0 9b       	sbis	0x16, 0	; 22
 1d0:	29 c0       	rjmp	.+82     	; 0x224 <main+0x82>
 1d2:	c4 e6       	ldi	r28, 0x64	; 100
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1d4:	d3 e6       	ldi	r29, 0x63	; 99
			
			setRedLED(255);
 1d6:	8f ef       	ldi	r24, 0xFF	; 255
 1d8:	d3 df       	rcall	.-90     	; 0x180 <setRedLED>
			
			for(uint8_t j=0; j<100 && !BUTTON_STATE_DOWN();j++ ) { 
 1da:	b0 99       	sbic	0x16, 0	; 22
 1dc:	ba c1       	rjmp	.+884    	; 0x552 <__stack+0x2f3>
 1de:	0a c0       	rjmp	.+20     	; 0x1f4 <main+0x52>
 1e0:	e9 ef       	ldi	r30, 0xF9	; 249
 1e2:	f0 e0       	ldi	r31, 0x00	; 0
 1e4:	31 97       	sbiw	r30, 0x01	; 1
 1e6:	f1 f7       	brne	.-4      	; 0x1e4 <main+0x42>
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <main+0x48>
 1ea:	00 00       	nop
 1ec:	81 50       	subi	r24, 0x01	; 1
 1ee:	11 f0       	breq	.+4      	; 0x1f4 <main+0x52>
 1f0:	b0 99       	sbic	0x16, 0	; 22
 1f2:	f6 cf       	rjmp	.-20     	; 0x1e0 <main+0x3e>
				_delay_ms(1);				
			}
			
			setRedLED(0);
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	c4 df       	rcall	.-120    	; 0x180 <setRedLED>
			setWhiteLED(255);
 1f8:	8f ef       	ldi	r24, 0xFF	; 255
 1fa:	b3 df       	rcall	.-154    	; 0x162 <setWhiteLED>
			
			for(uint8_t j=0; j<100 && !BUTTON_STATE_DOWN();j++ ) {
 1fc:	b0 99       	sbic	0x16, 0	; 22
 1fe:	a1 c1       	rjmp	.+834    	; 0x542 <__stack+0x2e3>
 200:	0a c0       	rjmp	.+20     	; 0x216 <main+0x74>
 202:	e9 ef       	ldi	r30, 0xF9	; 249
 204:	f0 e0       	ldi	r31, 0x00	; 0
 206:	31 97       	sbiw	r30, 0x01	; 1
 208:	f1 f7       	brne	.-4      	; 0x206 <main+0x64>
 20a:	00 c0       	rjmp	.+0      	; 0x20c <main+0x6a>
 20c:	00 00       	nop
 20e:	81 50       	subi	r24, 0x01	; 1
 210:	11 f0       	breq	.+4      	; 0x216 <main+0x74>
 212:	b0 99       	sbic	0x16, 0	; 22
 214:	f6 cf       	rjmp	.-20     	; 0x202 <main+0x60>
				_delay_ms(1);
			}
			
			setWhiteLED(0);
 216:	80 e0       	ldi	r24, 0x00	; 0
 218:	a4 df       	rcall	.-184    	; 0x162 <setWhiteLED>
					
			wdt_reset();
 21a:	a8 95       	wdr
 21c:	c1 50       	subi	r28, 0x01	; 1
		// Cold boot, run test mode
				
		// Blink back and forth to show LEDs work and solicit a button press	
		
			
		for(uint8_t i=0;i<100 && !BUTTON_STATE_DOWN(); i++ ) {
 21e:	11 f0       	breq	.+4      	; 0x224 <main+0x82>
 220:	b0 99       	sbic	0x16, 0	; 22
 222:	d9 cf       	rjmp	.-78     	; 0x1d6 <main+0x34>
 224:	89 e6       	ldi	r24, 0x69	; 105
 226:	98 e1       	ldi	r25, 0x18	; 24
 228:	01 97       	sbiw	r24, 0x01	; 1
 22a:	f1 f7       	brne	.-4      	; 0x228 <main+0x86>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <main+0x8c>
 22e:	00 00       	nop
 230:	63 c1       	rjmp	.+710    	; 0x4f8 <__stack+0x299>
		// Otherwise we just reset and the button was down when we woke, so likely it is stuck down 
		// and that is what caused the reset. In this case, show the user and then eventually disable the button.
		
		// Each pass of this loop takes ~1 sec.
		
		for( uint16_t t=0; (t <= BUTTON_TRANSIT_TIMEOUT_S) && BUTTON_STATE_DOWN(); t++ ) {
 232:	cb e0       	ldi	r28, 0x0B	; 11
 234:	d0 e0       	ldi	r29, 0x00	; 0
 236:	19 e0       	ldi	r17, 0x09	; 9
			
			// Start with LED off because it looks better when we are coming in from a watchdog
			// reset because the button was held down for more than 8 secs. Otherwise user
			// sees an odd blink pattern. 
			
			setWhiteLED(0);
 238:	80 e0       	ldi	r24, 0x00	; 0
 23a:	93 df       	rcall	.-218    	; 0x162 <setWhiteLED>
			
			// Leave the white LED off for 900 ms or until the button goes up
			
			for( uint8_t l=0; l<90 && BUTTON_STATE_DOWN() ; l++) {
 23c:	b0 9b       	sbis	0x16, 0	; 22
 23e:	79 c1       	rjmp	.+754    	; 0x532 <__stack+0x2d3>
 240:	0a c0       	rjmp	.+20     	; 0x256 <main+0xb4>
 242:	e3 ec       	ldi	r30, 0xC3	; 195
 244:	f9 e0       	ldi	r31, 0x09	; 9
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	f1 f7       	brne	.-4      	; 0x246 <main+0xa4>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <main+0xaa>
 24c:	00 00       	nop
 24e:	81 50       	subi	r24, 0x01	; 1
 250:	11 f0       	breq	.+4      	; 0x256 <main+0xb4>
 252:	b0 9b       	sbis	0x16, 0	; 22
 254:	f6 cf       	rjmp	.-20     	; 0x242 <main+0xa0>
				_delay_ms(10);
			}
			
						
			setWhiteLED(BUTTON_FEEDBACK_BRIGHTNESS);
 256:	84 e6       	ldi	r24, 0x64	; 100
 258:	84 df       	rcall	.-248    	; 0x162 <setWhiteLED>
			
			// Leave the white LED on for 100 ms or until the button goes up
			// Could do this as a single _delay_ms(100) but that might feel un-responsive
			
			
			for( uint8_t l=0; l<10 && BUTTON_STATE_DOWN() ; l++) {
 25a:	b0 9b       	sbis	0x16, 0	; 22
 25c:	62 c1       	rjmp	.+708    	; 0x522 <__stack+0x2c3>
 25e:	0a c0       	rjmp	.+20     	; 0x274 <__stack+0x15>
 260:	e3 ec       	ldi	r30, 0xC3	; 195
 262:	f9 e0       	ldi	r31, 0x09	; 9
 264:	31 97       	sbiw	r30, 0x01	; 1
 266:	f1 f7       	brne	.-4      	; 0x264 <__stack+0x5>
 268:	00 c0       	rjmp	.+0      	; 0x26a <__stack+0xb>
 26a:	00 00       	nop
 26c:	81 50       	subi	r24, 0x01	; 1
 26e:	11 f0       	breq	.+4      	; 0x274 <__stack+0x15>
 270:	b0 9b       	sbis	0x16, 0	; 22
 272:	f6 cf       	rjmp	.-20     	; 0x260 <__stack+0x1>
				_delay_ms(10);
			}
					
			wdt_reset();		
 274:	a8 95       	wdr
 276:	21 97       	sbiw	r28, 0x01	; 1
		// Otherwise we just reset and the button was down when we woke, so likely it is stuck down 
		// and that is what caused the reset. In this case, show the user and then eventually disable the button.
		
		// Each pass of this loop takes ~1 sec.
		
		for( uint16_t t=0; (t <= BUTTON_TRANSIT_TIMEOUT_S) && BUTTON_STATE_DOWN(); t++ ) {
 278:	11 f0       	breq	.+4      	; 0x27e <__stack+0x1f>
 27a:	b0 9b       	sbis	0x16, 0	; 22
 27c:	dd cf       	rjmp	.-70     	; 0x238 <main+0x96>
			
		}
		
		
		// Turn off LED before continuing
		setWhiteLED(0);
 27e:	80 e0       	ldi	r24, 0x00	; 0
 280:	70 df       	rcall	.-288    	; 0x162 <setWhiteLED>
 282:	89 e6       	ldi	r24, 0x69	; 105
 284:	98 e1       	ldi	r25, 0x18	; 24
 286:	01 97       	sbiw	r24, 0x01	; 1
 288:	f1 f7       	brne	.-4      	; 0x286 <__stack+0x27>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <__stack+0x2d>
 28c:	00 00       	nop
		
		_delay_ms(BUTTON_DEBOUNCE_TIME_MS);		
		
	}
	
	if (BUTTON_STATE_DOWN())	{			// Do we still have a stuck button?
 28e:	b0 99       	sbic	0x16, 0	; 22
 290:	24 c0       	rjmp	.+72     	; 0x2da <__stack+0x7b>


		// Indicate we are entering transit mode with a quick double flash of both LEDs		
				
		setRedLED(255);
 292:	8f ef       	ldi	r24, 0xFF	; 255
 294:	75 df       	rcall	.-278    	; 0x180 <setRedLED>
		setWhiteLED(255);
 296:	8f ef       	ldi	r24, 0xFF	; 255
 298:	64 df       	rcall	.-312    	; 0x162 <setWhiteLED>
 29a:	e7 ea       	ldi	r30, 0xA7	; 167
 29c:	f1 e6       	ldi	r31, 0x61	; 97
 29e:	31 97       	sbiw	r30, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <__stack+0x3f>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <__stack+0x45>
 2a4:	00 00       	nop
		_delay_ms(100);
		setRedLED(0);
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	6b df       	rcall	.-298    	; 0x180 <setRedLED>
		setWhiteLED(0);
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	5a df       	rcall	.-332    	; 0x162 <setWhiteLED>
 2ae:	87 ea       	ldi	r24, 0xA7	; 167
 2b0:	91 e6       	ldi	r25, 0x61	; 97
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <__stack+0x53>
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <__stack+0x59>
 2b8:	00 00       	nop
		_delay_ms(100);
		setRedLED(255);
 2ba:	8f ef       	ldi	r24, 0xFF	; 255
 2bc:	61 df       	rcall	.-318    	; 0x180 <setRedLED>
		setWhiteLED(255);
 2be:	8f ef       	ldi	r24, 0xFF	; 255
 2c0:	50 df       	rcall	.-352    	; 0x162 <setWhiteLED>
 2c2:	e7 ea       	ldi	r30, 0xA7	; 167
 2c4:	f1 e6       	ldi	r31, 0x61	; 97
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	f1 f7       	brne	.-4      	; 0x2c6 <__stack+0x67>
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <__stack+0x6d>
 2cc:	00 00       	nop
		_delay_ms(100);
		setRedLED(0);
 2ce:	80 e0       	ldi	r24, 0x00	; 0
 2d0:	57 df       	rcall	.-338    	; 0x180 <setRedLED>
		setWhiteLED(0);
 2d2:	80 e0       	ldi	r24, 0x00	; 0
 2d4:	46 df       	rcall	.-372    	; 0x162 <setWhiteLED>
		
	
		BUTTON_PORT &= ~_BV(BUTTON_BIT);	// Disable pull up to avoid running the battery down. 
 2d6:	c0 98       	cbi	0x18, 0	; 24
 2d8:	02 c0       	rjmp	.+4      	; 0x2de <__stack+0x7f>
	
	} else {
	
		// Leave pull-up enabled
	
		PCMSK1 = _BV(BUTTON_INT);				// Enable interrupt on button pin so we wake on a press
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	80 bd       	out	0x20, r24	; 32
	
	}
	
	PCMSK0 = _BV(EOC_INT) | _BV(CIP_INT);	// Enable interrupt on change in state-of-charge pin or end-of-charge pin no matter what
 2de:	83 e0       	ldi	r24, 0x03	; 3
 2e0:	82 bb       	out	0x12, r24	; 18
		
	GIMSK |= _BV(PCIE1) | _BV(PCIE0);		// Enable both pin change interrupt vectors (each individual pin was also be enabled above)
 2e2:	8b b7       	in	r24, 0x3b	; 59
 2e4:	80 63       	ori	r24, 0x30	; 48
 2e6:	8b bf       	out	0x3b, r24	; 59
	// Clear pending interrupt flags. This way we will only get an interrupt if something changes
	// after we read it. There is a race condition where something could change between the flag clear and the
	// reads below, so code should be able to deal with possible redundant interrupt and worst case
	// is that we get woken up an extra time and go back to sleep.	
	
	GIFR = _BV(PCIF1) | _BV(PCIF0);			// Clear interrupt flags so we will interrupt on any change after now...
 2e8:	80 e3       	ldi	r24, 0x30	; 48
 2ea:	8a bf       	out	0x3a, r24	; 58
																		
	if ( !CIP_STATE_ACTIVE() && !EOC_STATE_ACTIVE()  ) {			// Check if conditions are ALREADY true since we only wake on change....
 2ec:	c9 9b       	sbis	0x19, 1	; 25
 2ee:	1b c0       	rjmp	.+54     	; 0x326 <__stack+0xc7>
 2f0:	c8 9b       	sbis	0x19, 0	; 25
 2f2:	19 c0       	rjmp	.+50     	; 0x326 <__stack+0xc7>
			
		// Ok, it is bedtime!
												
		set_sleep_mode( SLEEP_MODE_PWR_DOWN );  // Go into deep sleep where only a pin change can wake us.. uses only ~0.1uA!
 2f4:	85 b7       	in	r24, 0x35	; 53
 2f6:	87 7e       	andi	r24, 0xE7	; 231
 2f8:	80 61       	ori	r24, 0x10	; 16
 2fa:	85 bf       	out	0x35, r24	; 53
		// This code disables the Watchdog. Note that we can not use the library wdt_disable() becuase it has a bug
		// that causes intermittent unwanted resets.
		
		// Note interrupts are already clear when we get here, otherwise we would need to worry about getting interrupted between the two following lines
		
		WDTCSR |= _BV(WDCE) | _BV(WDE);		// In the same operation, write a logic one to WDCE and WDE.
 2fc:	81 b5       	in	r24, 0x21	; 33
 2fe:	88 61       	ori	r24, 0x18	; 24
 300:	81 bd       	out	0x21, r24	; 33
											// Note we use OR to preserve the prescaler
		
		WDTCSR = 0;							//	Within the next four clock cycles, in the same operation, write the WDE and WDP bits
 302:	11 bc       	out	0x21, r1	; 33
											// as desired, but with the WDCE bit cleared.
		
		sleep_enable();							// "To enter any of the three sleep modes, the SE bit in MCUCR must be written to logic one and a SLEEP instruction must be executed."				
 304:	85 b7       	in	r24, 0x35	; 53
 306:	80 62       	ori	r24, 0x20	; 32
 308:	85 bf       	out	0x35, r24	; 53
		sei();                                  // Enable global interrupts. "When using the SEI instruction to enable interrupts, the instruction following SEI will be executed before any pending interrupts."		
 30a:	78 94       	sei
		sleep_cpu();							// This must come right after the sei() to avoid race condition
 30c:	88 95       	sleep

		// GOOD MORNING!
		// If we get here, then a button push or change in charger status woke s up....
			
		sleep_disable();						// "To avoid the MCU entering the sleep mode unless it is the programmer’s purpose, it is recommended to write the Sleep Enable (SE) bit to one just before the execution of the SLEEP instruction and to clear it immediately after waking up."
 30e:	85 b7       	in	r24, 0x35	; 53
 310:	8f 7d       	andi	r24, 0xDF	; 223
 312:	85 bf       	out	0x35, r24	; 53
		
		cli();									// We are awake now, and do don't care about interrupts anymore (out interrupt routines don't do anything anyway)
 314:	f8 94       	cli
 316:	99 e2       	ldi	r25, 0x29	; 41
 318:	88 e1       	ldi	r24, 0x18	; 24
 31a:	0f b6       	in	r0, 0x3f	; 63
 31c:	f8 94       	cli
 31e:	a8 95       	wdr
 320:	81 bd       	out	0x21, r24	; 33
 322:	0f be       	out	0x3f, r0	; 63
 324:	91 bd       	out	0x21, r25	; 33
		// This main loop runs for as long as the motor is on. 
		// It can be terminated by battery charger change of state, low battery detection, button press back to 0 speed, or long button press
		// All these changes terminate the loop in a reboot. 
		
		
		if (EOC_STATE_ACTIVE())		{		// End of charge?
 326:	c8 9b       	sbis	0x19, 0	; 25
 328:	19 c0       	rjmp	.+50     	; 0x35c <__stack+0xfd>
			REBOOT();
			
		}
		
				
		if (CIP_STATE_ACTIVE())		{		// Charging?
 32a:	c9 9b       	sbis	0x19, 1	; 25
 32c:	2f c0       	rjmp	.+94     	; 0x38c <__stack+0x12d>
 32e:	c0 e0       	ldi	r28, 0x00	; 0
				
			}
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
 330:	ff 24       	eor	r15, r15
 332:	f3 94       	inc	r15
												
			currentSpeedStep++;
			
			if (currentSpeedStep >= SPEED_STEP_COUNT )	{ // Cycled all the Way around?
								
				currentSpeedStep=0;
 334:	10 e0       	ldi	r17, 0x00	; 0
			REBOOT();
			
		}
		
				
		if (CIP_STATE_ACTIVE())		{		// Charging?
 336:	0f 2e       	mov	r0, r31
 338:	f4 ef       	ldi	r31, 0xF4	; 244
 33a:	9f 2e       	mov	r9, r31
 33c:	f0 2d       	mov	r31, r0
 33e:	ee 24       	eor	r14, r14
 340:	e3 94       	inc	r14
			
			_delay_ms(BUTTON_DEBOUNCE_TIME_MS);			// debounce going down...
			
			if ( currentSpeedStep ==0 ) {				// Special case first press turning on instantly
				
				updateMotor( pgm_read_word(&speedSteps[1].top) , pgm_read_word(&speedSteps[1].normailzedDuty), vccx10);		// Set new motor speed
 342:	0f 2e       	mov	r0, r31
 344:	f6 e2       	ldi	r31, 0x26	; 38
 346:	af 2e       	mov	r10, r31
 348:	f0 e0       	ldi	r31, 0x00	; 0
 34a:	bf 2e       	mov	r11, r31
 34c:	f0 2d       	mov	r31, r0
 34e:	0f 2e       	mov	r0, r31
 350:	f8 e2       	ldi	r31, 0x28	; 40
 352:	cf 2e       	mov	r12, r31
 354:	f0 e0       	ldi	r31, 0x00	; 0
 356:	df 2e       	mov	r13, r31
 358:	f0 2d       	mov	r31, r0
 35a:	43 c0       	rjmp	.+134    	; 0x3e2 <__stack+0x183>
// Turn the motor completely off- disconnects from PWM generator

void motorOff(void) {

		
	TCCR1A = 0;		// Disconnect Timer1A outputs from pins. "Normal port operation, OC1B disconnected"	
 35c:	1f bc       	out	0x2f, r1	; 47
		
		if (EOC_STATE_ACTIVE())		{		// End of charge?
			
			motorOff();						//Turn motor off in case were running before plug went in
			
			setWhiteLED(255);				// White LED full on
 35e:	8f ef       	ldi	r24, 0xFF	; 255
 360:	00 df       	rcall	.-512    	; 0x162 <setWhiteLED>
 362:	87 ea       	ldi	r24, 0xA7	; 167
 364:	91 e6       	ldi	r25, 0x61	; 97
 366:	01 97       	sbiw	r24, 0x01	; 1
 368:	f1 f7       	brne	.-4      	; 0x366 <__stack+0x107>
 36a:	00 c0       	rjmp	.+0      	; 0x36c <__stack+0x10d>
 36c:	00 00       	nop
			
			
			_delay_ms( JACK_DEBOUNCE_TIME_MS );
			
			while (EOC_STATE_ACTIVE()); 	// White LED on for as long as we are charging....
 36e:	c8 9b       	sbis	0x19, 0	; 25
 370:	fe cf       	rjmp	.-4      	; 0x36e <__stack+0x10f>
			// Note that this will watchdog timeout after 8 seconds and reboot us,
			// After which we will immediately fall right back to here and continue to show the white LED
			
			setWhiteLED(0);					// Turn it off now, for instant feedback if unplugged (otherwise it will be on for extra 250ms waiting for watchdog reset)
 372:	80 e0       	ldi	r24, 0x00	; 0
 374:	f6 de       	rcall	.-532    	; 0x162 <setWhiteLED>
 376:	99 e0       	ldi	r25, 0x09	; 9
 378:	88 e1       	ldi	r24, 0x18	; 24
 37a:	0f b6       	in	r0, 0x3f	; 63
 37c:	f8 94       	cli
 37e:	a8 95       	wdr
 380:	81 bd       	out	0x21, r24	; 33
 382:	0f be       	out	0x3f, r0	; 63
 384:	91 bd       	out	0x21, r25	; 33
			
			// Charger unplugged, reboot for goo measure
									
			REBOOT();
 386:	ff cf       	rjmp	.-2      	; 0x386 <__stack+0x127>
			
		}
		
				
		if (CIP_STATE_ACTIVE())		{		// Charging?
 388:	c9 99       	sbic	0x19, 1	; 25
 38a:	2b c0       	rjmp	.+86     	; 0x3e2 <__stack+0x183>
// Turn the motor completely off- disconnects from PWM generator

void motorOff(void) {

		
	TCCR1A = 0;		// Disconnect Timer1A outputs from pins. "Normal port operation, OC1B disconnected"	
 38c:	1f bc       	out	0x2f, r1	; 47
 38e:	e7 ea       	ldi	r30, 0xA7	; 167
 390:	f1 e6       	ldi	r31, 0x61	; 97
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	f1 f7       	brne	.-4      	; 0x392 <__stack+0x133>
 396:	00 c0       	rjmp	.+0      	; 0x398 <__stack+0x139>
 398:	00 00       	nop
			uint8_t brightness=0;
			int8_t direction=1;
			
			_delay_ms( JACK_DEBOUNCE_TIME_MS );
						
			while (CIP_STATE_ACTIVE())	{	// White LED pulse for as long as we are charging....
 39a:	c9 99       	sbic	0x19, 1	; 25
 39c:	17 c0       	rjmp	.+46     	; 0x3cc <__stack+0x16d>
 39e:	d1 e0       	ldi	r29, 0x01	; 1
 3a0:	c0 e0       	ldi	r28, 0x00	; 0
				
				setWhiteLED(brightness);
				
				if (brightness==255) {
					
					direction=-1;
 3a2:	0f ef       	ldi	r16, 0xFF	; 255
					
				} else if (brightness==0) {
				
					direction=1;
 3a4:	11 e0       	ldi	r17, 0x01	; 1
			
			_delay_ms( JACK_DEBOUNCE_TIME_MS );
						
			while (CIP_STATE_ACTIVE())	{	// White LED pulse for as long as we are charging....
				
				setWhiteLED(brightness);
 3a6:	8c 2f       	mov	r24, r28
 3a8:	dc de       	rcall	.-584    	; 0x162 <setWhiteLED>
				
				if (brightness==255) {
 3aa:	cf 3f       	cpi	r28, 0xFF	; 255
 3ac:	21 f0       	breq	.+8      	; 0x3b6 <__stack+0x157>
					
					direction=-1;
					
				} else if (brightness==0) {
 3ae:	c1 11       	cpse	r28, r1
 3b0:	03 c0       	rjmp	.+6      	; 0x3b8 <__stack+0x159>
				
					direction=1;
 3b2:	d1 2f       	mov	r29, r17
 3b4:	01 c0       	rjmp	.+2      	; 0x3b8 <__stack+0x159>
				
				setWhiteLED(brightness);
				
				if (brightness==255) {
					
					direction=-1;
 3b6:	d0 2f       	mov	r29, r16
				
					direction=1;
					
				}
				
				brightness+=direction;
 3b8:	cd 0f       	add	r28, r29
 3ba:	89 ef       	ldi	r24, 0xF9	; 249
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	01 97       	sbiw	r24, 0x01	; 1
 3c0:	f1 f7       	brne	.-4      	; 0x3be <__stack+0x15f>
 3c2:	00 c0       	rjmp	.+0      	; 0x3c4 <__stack+0x165>
 3c4:	00 00       	nop
				
				_delay_ms(1);		// Slows the speed of the rampping LED
								
				wdt_reset();
 3c6:	a8 95       	wdr
			uint8_t brightness=0;
			int8_t direction=1;
			
			_delay_ms( JACK_DEBOUNCE_TIME_MS );
						
			while (CIP_STATE_ACTIVE())	{	// White LED pulse for as long as we are charging....
 3c8:	c9 9b       	sbis	0x19, 1	; 25
 3ca:	ed cf       	rjmp	.-38     	; 0x3a6 <__stack+0x147>
								
				wdt_reset();
				
			}
			
			setWhiteLED(0);					// Turn it off now, for instant feedback if unplugged (otherwise it will be on for extra 250ms waiting for watchdog reset)
 3cc:	80 e0       	ldi	r24, 0x00	; 0
 3ce:	c9 de       	rcall	.-622    	; 0x162 <setWhiteLED>
 3d0:	99 e0       	ldi	r25, 0x09	; 9
 3d2:	88 e1       	ldi	r24, 0x18	; 24
 3d4:	0f b6       	in	r0, 0x3f	; 63
 3d6:	f8 94       	cli
 3d8:	a8 95       	wdr
 3da:	81 bd       	out	0x21, r24	; 33
 3dc:	0f be       	out	0x3f, r0	; 63
 3de:	91 bd       	out	0x21, r25	; 33
						
			// All done charing, reboot for good measure
			
			REBOOT();
 3e0:	ff cf       	rjmp	.-2      	; 0x3e0 <__stack+0x181>
			
		}
		
				
		uint8_t vccx10 = readVccVoltage();				// Capture the current power supply voltage. This takes ~1ms and will be needed multiple times below
 3e2:	3f de       	rcall	.-898    	; 0x62 <readVccVoltage>
 3e4:	08 2f       	mov	r16, r24
		
		if ( vccx10 <= LOW_BATTERY_VOLTS_COLDx10) {
 3e6:	8f 31       	cpi	r24, 0x1F	; 31
 3e8:	00 f5       	brcc	.+64     	; 0x42a <__stack+0x1cb>
			
			if ( (currentSpeedStep==0) || ( vccx10 <= LOW_BATTERY_VOLTS_WARMx10) ) {	// Motor off, or running and really low?
 3ea:	cc 23       	and	r28, r28
 3ec:	19 f0       	breq	.+6      	; 0x3f4 <__stack+0x195>
 3ee:	8d 31       	cpi	r24, 0x1D	; 29
 3f0:	08 f0       	brcs	.+2      	; 0x3f4 <__stack+0x195>
 3f2:	90 c0       	rjmp	.+288    	; 0x514 <__stack+0x2b5>
// Turn the motor completely off- disconnects from PWM generator

void motorOff(void) {

		
	TCCR1A = 0;		// Disconnect Timer1A outputs from pins. "Normal port operation, OC1B disconnected"	
 3f4:	1f bc       	out	0x2f, r1	; 47
			
			if ( (currentSpeedStep==0) || ( vccx10 <= LOW_BATTERY_VOLTS_WARMx10) ) {	// Motor off, or running and really low?
			
				motorOff();
			
				setWhiteLED(0);									// Needed becuase both LEDs might be on if we are in the middle of a button press
 3f6:	80 e0       	ldi	r24, 0x00	; 0
 3f8:	b4 de       	rcall	.-664    	; 0x162 <setWhiteLED>
			
				setRedLED(255);
 3fa:	8f ef       	ldi	r24, 0xFF	; 255
 3fc:	c1 de       	rcall	.-638    	; 0x180 <setRedLED>
 3fe:	9f e3       	ldi	r25, 0x3F	; 63
 400:	ed e0       	ldi	r30, 0x0D	; 13
 402:	f3 e0       	ldi	r31, 0x03	; 3
 404:	91 50       	subi	r25, 0x01	; 1
 406:	e0 40       	sbci	r30, 0x00	; 0
 408:	f0 40       	sbci	r31, 0x00	; 0
 40a:	e1 f7       	brne	.-8      	; 0x404 <__stack+0x1a5>
 40c:	00 c0       	rjmp	.+0      	; 0x40e <__stack+0x1af>
 40e:	00 00       	nop
			
				_delay_ms(LOW_BATTERY_LED_ONTIME_MS);			// Show red LED to user to show low battery
				
				while (BUTTON_STATE_DOWN());					// Wait for button to be released if pressed
 410:	b0 9b       	sbis	0x16, 0	; 22
 412:	fe cf       	rjmp	.-4      	; 0x410 <__stack+0x1b1>
																// Will watchdog timeout in 8 seconds if stuff
				setRedLED(0);
 414:	80 e0       	ldi	r24, 0x00	; 0
 416:	b4 de       	rcall	.-664    	; 0x180 <setRedLED>
 418:	99 e0       	ldi	r25, 0x09	; 9
 41a:	88 e1       	ldi	r24, 0x18	; 24
 41c:	0f b6       	in	r0, 0x3f	; 63
 41e:	f8 94       	cli
 420:	a8 95       	wdr
 422:	81 bd       	out	0x21, r24	; 33
 424:	0f be       	out	0x3f, r0	; 63
 426:	91 bd       	out	0x21, r25	; 33
						
				REBOOT();
 428:	ff cf       	rjmp	.-2      	; 0x428 <__stack+0x1c9>
		}

								
		uint8_t buttonPressedFlag=0;
		
		if (BUTTON_STATE_DOWN())	{		// Button pushed?
 42a:	b0 99       	sbic	0x16, 0	; 22
 42c:	34 c0       	rjmp	.+104    	; 0x496 <__stack+0x237>
			
			setWhiteLED(BUTTON_FEEDBACK_BRIGHTNESS);
 42e:	84 e6       	ldi	r24, 0x64	; 100
 430:	98 de       	rcall	.-720    	; 0x162 <setWhiteLED>
 432:	89 e6       	ldi	r24, 0x69	; 105
 434:	98 e1       	ldi	r25, 0x18	; 24
 436:	01 97       	sbiw	r24, 0x01	; 1
 438:	f1 f7       	brne	.-4      	; 0x436 <__stack+0x1d7>
 43a:	00 c0       	rjmp	.+0      	; 0x43c <__stack+0x1dd>
 43c:	00 00       	nop
			
			_delay_ms(BUTTON_DEBOUNCE_TIME_MS);			// debounce going down...
			
			if ( currentSpeedStep ==0 ) {				// Special case first press turning on instantly
 43e:	c1 11       	cpse	r28, r1
 440:	6d c0       	rjmp	.+218    	; 0x51c <__stack+0x2bd>
				
				updateMotor( pgm_read_word(&speedSteps[1].top) , pgm_read_word(&speedSteps[1].normailzedDuty), vccx10);		// Set new motor speed
 442:	f5 01       	movw	r30, r10
 444:	65 91       	lpm	r22, Z+
 446:	74 91       	lpm	r23, Z
 448:	f6 01       	movw	r30, r12
 44a:	85 91       	lpm	r24, Z+
 44c:	94 91       	lpm	r25, Z
 44e:	40 2f       	mov	r20, r16
 450:	1f de       	rcall	.-962    	; 0x90 <updateMotor>

			}
			
			uint16_t buttonDownCount=0;
			
			while (BUTTON_STATE_DOWN()) {			// Wait for button to go back up or longpress timeout
 452:	b0 9b       	sbis	0x16, 0	; 22
 454:	10 c0       	rjmp	.+32     	; 0x476 <__stack+0x217>
 456:	85 c0       	rjmp	.+266    	; 0x562 <__stack+0x303>
 458:	21 50       	subi	r18, 0x01	; 1
 45a:	31 09       	sbc	r19, r1
				
				if (buttonDownCount++ >= BUTTON_LONG_PRESS_MS ) {		// Long press? Shut motor off
 45c:	71 f4       	brne	.+28     	; 0x47a <__stack+0x21b>
// Turn the motor completely off- disconnects from PWM generator

void motorOff(void) {

		
	TCCR1A = 0;		// Disconnect Timer1A outputs from pins. "Normal port operation, OC1B disconnected"	
 45e:	1f bc       	out	0x2f, r1	; 47
					// The reboot would do both of these anyway, but we do them redundantly here so UI feels responsive-
					// The full reboot cycle takes 100+ ms.
					
					motorOff();
										
					setWhiteLED(0);
 460:	80 e0       	ldi	r24, 0x00	; 0
 462:	7f de       	rcall	.-770    	; 0x162 <setWhiteLED>
 464:	99 e0       	ldi	r25, 0x09	; 9
 466:	88 e1       	ldi	r24, 0x18	; 24
 468:	0f b6       	in	r0, 0x3f	; 63
 46a:	f8 94       	cli
 46c:	a8 95       	wdr
 46e:	81 bd       	out	0x21, r24	; 33
 470:	0f be       	out	0x3f, r0	; 63
 472:	91 bd       	out	0x21, r25	; 33
					
					REBOOT();
 474:	ff cf       	rjmp	.-2      	; 0x474 <__stack+0x215>
			REBOOT();
			
		}
		
				
		if (CIP_STATE_ACTIVE())		{		// Charging?
 476:	29 2d       	mov	r18, r9
 478:	3e 2d       	mov	r19, r14
 47a:	e9 ef       	ldi	r30, 0xF9	; 249
 47c:	f0 e0       	ldi	r31, 0x00	; 0
 47e:	31 97       	sbiw	r30, 0x01	; 1
 480:	f1 f7       	brne	.-4      	; 0x47e <__stack+0x21f>
 482:	00 c0       	rjmp	.+0      	; 0x484 <__stack+0x225>
 484:	00 00       	nop

			}
			
			uint16_t buttonDownCount=0;
			
			while (BUTTON_STATE_DOWN()) {			// Wait for button to go back up or longpress timeout
 486:	b0 9b       	sbis	0x16, 0	; 22
 488:	e7 cf       	rjmp	.-50     	; 0x458 <__stack+0x1f9>
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
												
			currentSpeedStep++;
 48a:	cf 5f       	subi	r28, 0xFF	; 255
			
			if (currentSpeedStep >= SPEED_STEP_COUNT )	{ // Cycled all the Way around?
 48c:	c4 30       	cpi	r28, 0x04	; 4
 48e:	28 f0       	brcs	.+10     	; 0x49a <__stack+0x23b>
				
			}
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
 490:	df 2d       	mov	r29, r15
												
			currentSpeedStep++;
			
			if (currentSpeedStep >= SPEED_STEP_COUNT )	{ // Cycled all the Way around?
								
				currentSpeedStep=0;
 492:	c1 2f       	mov	r28, r17
 494:	03 c0       	rjmp	.+6      	; 0x49c <__stack+0x23d>
				
			}
		}

								
		uint8_t buttonPressedFlag=0;
 496:	d1 2f       	mov	r29, r17
 498:	01 c0       	rjmp	.+2      	; 0x49c <__stack+0x23d>
				
			}
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
 49a:	df 2d       	mov	r29, r15
				
			}
						
		}
											
		updateMotor( pgm_read_word(&speedSteps[currentSpeedStep].top) , pgm_read_word(&speedSteps[currentSpeedStep].normailzedDuty), vccx10);		// Set new motor speed
 49c:	8c 2f       	mov	r24, r28
 49e:	90 e0       	ldi	r25, 0x00	; 0
 4a0:	88 0f       	add	r24, r24
 4a2:	99 1f       	adc	r25, r25
 4a4:	88 0f       	add	r24, r24
 4a6:	99 1f       	adc	r25, r25
 4a8:	fc 01       	movw	r30, r24
 4aa:	ee 5d       	subi	r30, 0xDE	; 222
 4ac:	ff 4f       	sbci	r31, 0xFF	; 255
 4ae:	65 91       	lpm	r22, Z+
 4b0:	74 91       	lpm	r23, Z
 4b2:	8c 5d       	subi	r24, 0xDC	; 220
 4b4:	9f 4f       	sbci	r25, 0xFF	; 255
 4b6:	fc 01       	movw	r30, r24
 4b8:	85 91       	lpm	r24, Z+
 4ba:	94 91       	lpm	r25, Z
 4bc:	40 2f       	mov	r20, r16
 4be:	e8 dd       	rcall	.-1072   	; 0x90 <updateMotor>
		
		if (buttonPressedFlag) {
 4c0:	dd 23       	and	r29, r29
 4c2:	41 f0       	breq	.+16     	; 0x4d4 <__stack+0x275>
			
			// Button released, white LED off again
			
			setWhiteLED(0);
 4c4:	81 2f       	mov	r24, r17
 4c6:	4d de       	rcall	.-870    	; 0x162 <setWhiteLED>
 4c8:	89 e6       	ldi	r24, 0x69	; 105
 4ca:	98 e1       	ldi	r25, 0x18	; 24
 4cc:	01 97       	sbiw	r24, 0x01	; 1
 4ce:	f1 f7       	brne	.-4      	; 0x4cc <__stack+0x26d>
 4d0:	00 c0       	rjmp	.+0      	; 0x4d2 <__stack+0x273>
 4d2:	00 00       	nop
			_delay_ms(BUTTON_DEBOUNCE_TIME_MS);		// debounce the button returning back up
			
			
		}
		
		if (currentSpeedStep==0) {		// Either we stepped though the settings back to off, or we got a spurious wake up
 4d4:	c1 11       	cpse	r28, r1
 4d6:	09 c0       	rjmp	.+18     	; 0x4ea <__stack+0x28b>
 4d8:	99 e0       	ldi	r25, 0x09	; 9
 4da:	88 e1       	ldi	r24, 0x18	; 24
 4dc:	0f b6       	in	r0, 0x3f	; 63
 4de:	f8 94       	cli
 4e0:	a8 95       	wdr
 4e2:	81 bd       	out	0x21, r24	; 33
 4e4:	0f be       	out	0x3f, r0	; 63
 4e6:	91 bd       	out	0x21, r25	; 33
			REBOOT();	
 4e8:	ff cf       	rjmp	.-2      	; 0x4e8 <__stack+0x289>
							

		// If we get to here, then we check for a low battery and had the chance to reboot if we found one,
		// so ok to postpone reset...		
		
		wdt_reset();
 4ea:	a8 95       	wdr
		// This main loop runs for as long as the motor is on. 
		// It can be terminated by battery charger change of state, low battery detection, button press back to 0 speed, or long button press
		// All these changes terminate the loop in a reboot. 
		
		
		if (EOC_STATE_ACTIVE())		{		// End of charge?
 4ec:	c8 99       	sbic	0x19, 0	; 25
 4ee:	4c cf       	rjmp	.-360    	; 0x388 <__stack+0x129>
 4f0:	35 cf       	rjmp	.-406    	; 0x35c <__stack+0xfd>
		// Otherwise we just reset and the button was down when we woke, so likely it is stuck down 
		// and that is what caused the reset. In this case, show the user and then eventually disable the button.
		
		// Each pass of this loop takes ~1 sec.
		
		for( uint16_t t=0; (t <= BUTTON_TRANSIT_TIMEOUT_S) && BUTTON_STATE_DOWN(); t++ ) {
 4f2:	b0 9b       	sbis	0x16, 0	; 22
 4f4:	9e ce       	rjmp	.-708    	; 0x232 <main+0x90>
 4f6:	c3 ce       	rjmp	.-634    	; 0x27e <__stack+0x1f>
	}
												
	// Ready to begin normal operation!	
	
	
	if (BUTTON_STATE_DOWN())	{		// Possible stuck button?
 4f8:	b0 9b       	sbis	0x16, 0	; 22
 4fa:	fb cf       	rjmp	.-10     	; 0x4f2 <__stack+0x293>
 4fc:	c8 ce       	rjmp	.-624    	; 0x28e <__stack+0x2f>
								
		uint8_t buttonPressedFlag=0;
		
		if (BUTTON_STATE_DOWN())	{		// Button pushed?
			
			setWhiteLED(BUTTON_FEEDBACK_BRIGHTNESS);
 4fe:	84 e6       	ldi	r24, 0x64	; 100
 500:	30 de       	rcall	.-928    	; 0x162 <setWhiteLED>
 502:	e9 e6       	ldi	r30, 0x69	; 105
 504:	f8 e1       	ldi	r31, 0x18	; 24
 506:	31 97       	sbiw	r30, 0x01	; 1
 508:	f1 f7       	brne	.-4      	; 0x506 <__stack+0x2a7>
 50a:	00 c0       	rjmp	.+0      	; 0x50c <__stack+0x2ad>
 50c:	00 00       	nop

			}
			
			uint16_t buttonDownCount=0;
			
			while (BUTTON_STATE_DOWN()) {			// Wait for button to go back up or longpress timeout
 50e:	b0 9b       	sbis	0x16, 0	; 22
 510:	b2 cf       	rjmp	.-156    	; 0x476 <__stack+0x217>
 512:	bb cf       	rjmp	.-138    	; 0x48a <__stack+0x22b>
		}

								
		uint8_t buttonPressedFlag=0;
		
		if (BUTTON_STATE_DOWN())	{		// Button pushed?
 514:	b0 9b       	sbis	0x16, 0	; 22
 516:	f3 cf       	rjmp	.-26     	; 0x4fe <__stack+0x29f>
				
			}
		}

								
		uint8_t buttonPressedFlag=0;
 518:	d1 2f       	mov	r29, r17
 51a:	c0 cf       	rjmp	.-128    	; 0x49c <__stack+0x23d>

			}
			
			uint16_t buttonDownCount=0;
			
			while (BUTTON_STATE_DOWN()) {			// Wait for button to go back up or longpress timeout
 51c:	b0 9b       	sbis	0x16, 0	; 22
 51e:	ab cf       	rjmp	.-170    	; 0x476 <__stack+0x217>
 520:	b4 cf       	rjmp	.-152    	; 0x48a <__stack+0x22b>
 522:	83 ec       	ldi	r24, 0xC3	; 195
 524:	99 e0       	ldi	r25, 0x09	; 9
 526:	01 97       	sbiw	r24, 0x01	; 1
 528:	f1 f7       	brne	.-4      	; 0x526 <__stack+0x2c7>
 52a:	00 c0       	rjmp	.+0      	; 0x52c <__stack+0x2cd>
 52c:	00 00       	nop
 52e:	81 2f       	mov	r24, r17
 530:	9f ce       	rjmp	.-706    	; 0x270 <__stack+0x11>
 532:	e3 ec       	ldi	r30, 0xC3	; 195
 534:	f9 e0       	ldi	r31, 0x09	; 9
 536:	31 97       	sbiw	r30, 0x01	; 1
 538:	f1 f7       	brne	.-4      	; 0x536 <__stack+0x2d7>
 53a:	00 c0       	rjmp	.+0      	; 0x53c <__stack+0x2dd>
 53c:	00 00       	nop
 53e:	89 e5       	ldi	r24, 0x59	; 89
 540:	88 ce       	rjmp	.-752    	; 0x252 <main+0xb0>
 542:	89 ef       	ldi	r24, 0xF9	; 249
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	01 97       	sbiw	r24, 0x01	; 1
 548:	f1 f7       	brne	.-4      	; 0x546 <__stack+0x2e7>
 54a:	00 c0       	rjmp	.+0      	; 0x54c <__stack+0x2ed>
 54c:	00 00       	nop
 54e:	8d 2f       	mov	r24, r29
 550:	60 ce       	rjmp	.-832    	; 0x212 <main+0x70>
 552:	e9 ef       	ldi	r30, 0xF9	; 249
 554:	f0 e0       	ldi	r31, 0x00	; 0
 556:	31 97       	sbiw	r30, 0x01	; 1
 558:	f1 f7       	brne	.-4      	; 0x556 <__stack+0x2f7>
 55a:	00 c0       	rjmp	.+0      	; 0x55c <__stack+0x2fd>
 55c:	00 00       	nop
 55e:	8d 2f       	mov	r24, r29
 560:	47 ce       	rjmp	.-882    	; 0x1f0 <main+0x4e>
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
												
			currentSpeedStep++;
 562:	cf 5f       	subi	r28, 0xFF	; 255
				
			}
			
			// Pressed less than a long press
			
			buttonPressedFlag=1;		// Debounce after setting new motor speed so UI feels responsive
 564:	df 2d       	mov	r29, r15
 566:	9a cf       	rjmp	.-204    	; 0x49c <__stack+0x23d>

00000568 <__udivmodhi4>:
 568:	aa 1b       	sub	r26, r26
 56a:	bb 1b       	sub	r27, r27
 56c:	51 e1       	ldi	r21, 0x11	; 17
 56e:	07 c0       	rjmp	.+14     	; 0x57e <__udivmodhi4_ep>

00000570 <__udivmodhi4_loop>:
 570:	aa 1f       	adc	r26, r26
 572:	bb 1f       	adc	r27, r27
 574:	a6 17       	cp	r26, r22
 576:	b7 07       	cpc	r27, r23
 578:	10 f0       	brcs	.+4      	; 0x57e <__udivmodhi4_ep>
 57a:	a6 1b       	sub	r26, r22
 57c:	b7 0b       	sbc	r27, r23

0000057e <__udivmodhi4_ep>:
 57e:	88 1f       	adc	r24, r24
 580:	99 1f       	adc	r25, r25
 582:	5a 95       	dec	r21
 584:	a9 f7       	brne	.-22     	; 0x570 <__udivmodhi4_loop>
 586:	80 95       	com	r24
 588:	90 95       	com	r25
 58a:	bc 01       	movw	r22, r24
 58c:	cd 01       	movw	r24, r26
 58e:	08 95       	ret

00000590 <__udivmodsi4>:
 590:	a1 e2       	ldi	r26, 0x21	; 33
 592:	1a 2e       	mov	r1, r26
 594:	aa 1b       	sub	r26, r26
 596:	bb 1b       	sub	r27, r27
 598:	fd 01       	movw	r30, r26
 59a:	0d c0       	rjmp	.+26     	; 0x5b6 <__udivmodsi4_ep>

0000059c <__udivmodsi4_loop>:
 59c:	aa 1f       	adc	r26, r26
 59e:	bb 1f       	adc	r27, r27
 5a0:	ee 1f       	adc	r30, r30
 5a2:	ff 1f       	adc	r31, r31
 5a4:	a2 17       	cp	r26, r18
 5a6:	b3 07       	cpc	r27, r19
 5a8:	e4 07       	cpc	r30, r20
 5aa:	f5 07       	cpc	r31, r21
 5ac:	20 f0       	brcs	.+8      	; 0x5b6 <__udivmodsi4_ep>
 5ae:	a2 1b       	sub	r26, r18
 5b0:	b3 0b       	sbc	r27, r19
 5b2:	e4 0b       	sbc	r30, r20
 5b4:	f5 0b       	sbc	r31, r21

000005b6 <__udivmodsi4_ep>:
 5b6:	66 1f       	adc	r22, r22
 5b8:	77 1f       	adc	r23, r23
 5ba:	88 1f       	adc	r24, r24
 5bc:	99 1f       	adc	r25, r25
 5be:	1a 94       	dec	r1
 5c0:	69 f7       	brne	.-38     	; 0x59c <__udivmodsi4_loop>
 5c2:	60 95       	com	r22
 5c4:	70 95       	com	r23
 5c6:	80 95       	com	r24
 5c8:	90 95       	com	r25
 5ca:	9b 01       	movw	r18, r22
 5cc:	ac 01       	movw	r20, r24
 5ce:	bd 01       	movw	r22, r26
 5d0:	cf 01       	movw	r24, r30
 5d2:	08 95       	ret

000005d4 <__mulsidi3>:
 5d4:	68 94       	set
 5d6:	00 13       	cpse	r16, r16

000005d8 <__umulsidi3>:
 5d8:	e8 94       	clt
 5da:	a0 e0       	ldi	r26, 0x00	; 0
 5dc:	b0 e0       	ldi	r27, 0x00	; 0
 5de:	e2 ef       	ldi	r30, 0xF2	; 242
 5e0:	f2 e0       	ldi	r31, 0x02	; 2
 5e2:	1d c0       	rjmp	.+58     	; 0x61e <__prologue_saves__+0x10>
 5e4:	ef ef       	ldi	r30, 0xFF	; 255
 5e6:	e7 f9       	bld	r30, 7
 5e8:	59 01       	movw	r10, r18
 5ea:	6a 01       	movw	r12, r20
 5ec:	5e 23       	and	r21, r30
 5ee:	55 0f       	add	r21, r21
 5f0:	ee 08       	sbc	r14, r14
 5f2:	fe 2c       	mov	r15, r14
 5f4:	87 01       	movw	r16, r14
 5f6:	9b 01       	movw	r18, r22
 5f8:	ac 01       	movw	r20, r24
 5fa:	9e 23       	and	r25, r30
 5fc:	99 0f       	add	r25, r25
 5fe:	66 0b       	sbc	r22, r22
 600:	76 2f       	mov	r23, r22
 602:	cb 01       	movw	r24, r22
 604:	3b d0       	rcall	.+118    	; 0x67c <__muldi3>
 606:	cd b7       	in	r28, 0x3d	; 61
 608:	de b7       	in	r29, 0x3e	; 62
 60a:	ea e0       	ldi	r30, 0x0A	; 10
 60c:	24 c0       	rjmp	.+72     	; 0x656 <__epilogue_restores__+0x10>

0000060e <__prologue_saves__>:
 60e:	2f 92       	push	r2
 610:	3f 92       	push	r3
 612:	4f 92       	push	r4
 614:	5f 92       	push	r5
 616:	6f 92       	push	r6
 618:	7f 92       	push	r7
 61a:	8f 92       	push	r8
 61c:	9f 92       	push	r9
 61e:	af 92       	push	r10
 620:	bf 92       	push	r11
 622:	cf 92       	push	r12
 624:	df 92       	push	r13
 626:	ef 92       	push	r14
 628:	ff 92       	push	r15
 62a:	0f 93       	push	r16
 62c:	1f 93       	push	r17
 62e:	cf 93       	push	r28
 630:	df 93       	push	r29
 632:	cd b7       	in	r28, 0x3d	; 61
 634:	de b7       	in	r29, 0x3e	; 62
 636:	ca 1b       	sub	r28, r26
 638:	db 0b       	sbc	r29, r27
 63a:	0f b6       	in	r0, 0x3f	; 63
 63c:	f8 94       	cli
 63e:	de bf       	out	0x3e, r29	; 62
 640:	0f be       	out	0x3f, r0	; 63
 642:	cd bf       	out	0x3d, r28	; 61
 644:	09 94       	ijmp

00000646 <__epilogue_restores__>:
 646:	2a 88       	ldd	r2, Y+18	; 0x12
 648:	39 88       	ldd	r3, Y+17	; 0x11
 64a:	48 88       	ldd	r4, Y+16	; 0x10
 64c:	5f 84       	ldd	r5, Y+15	; 0x0f
 64e:	6e 84       	ldd	r6, Y+14	; 0x0e
 650:	7d 84       	ldd	r7, Y+13	; 0x0d
 652:	8c 84       	ldd	r8, Y+12	; 0x0c
 654:	9b 84       	ldd	r9, Y+11	; 0x0b
 656:	aa 84       	ldd	r10, Y+10	; 0x0a
 658:	b9 84       	ldd	r11, Y+9	; 0x09
 65a:	c8 84       	ldd	r12, Y+8	; 0x08
 65c:	df 80       	ldd	r13, Y+7	; 0x07
 65e:	ee 80       	ldd	r14, Y+6	; 0x06
 660:	fd 80       	ldd	r15, Y+5	; 0x05
 662:	0c 81       	ldd	r16, Y+4	; 0x04
 664:	1b 81       	ldd	r17, Y+3	; 0x03
 666:	aa 81       	ldd	r26, Y+2	; 0x02
 668:	b9 81       	ldd	r27, Y+1	; 0x01
 66a:	ce 0f       	add	r28, r30
 66c:	d1 1d       	adc	r29, r1
 66e:	0f b6       	in	r0, 0x3f	; 63
 670:	f8 94       	cli
 672:	de bf       	out	0x3e, r29	; 62
 674:	0f be       	out	0x3f, r0	; 63
 676:	cd bf       	out	0x3d, r28	; 61
 678:	ed 01       	movw	r28, r26
 67a:	08 95       	ret

0000067c <__muldi3>:
 67c:	df 93       	push	r29
 67e:	cf 93       	push	r28
 680:	9f 92       	push	r9
 682:	a0 e4       	ldi	r26, 0x40	; 64
 684:	9a 2e       	mov	r9, r26
 686:	00 24       	eor	r0, r0
 688:	d0 01       	movw	r26, r0
 68a:	e0 01       	movw	r28, r0
 68c:	f0 01       	movw	r30, r0
 68e:	16 95       	lsr	r17
 690:	07 95       	ror	r16
 692:	f7 94       	ror	r15
 694:	e7 94       	ror	r14
 696:	d7 94       	ror	r13
 698:	c7 94       	ror	r12
 69a:	b7 94       	ror	r11
 69c:	a7 94       	ror	r10
 69e:	48 f4       	brcc	.+18     	; 0x6b2 <__muldi3+0x36>
 6a0:	10 68       	ori	r17, 0x80	; 128
 6a2:	a2 0f       	add	r26, r18
 6a4:	b3 1f       	adc	r27, r19
 6a6:	c4 1f       	adc	r28, r20
 6a8:	d5 1f       	adc	r29, r21
 6aa:	e6 1f       	adc	r30, r22
 6ac:	f7 1f       	adc	r31, r23
 6ae:	08 1e       	adc	r0, r24
 6b0:	19 1e       	adc	r1, r25
 6b2:	22 0f       	add	r18, r18
 6b4:	33 1f       	adc	r19, r19
 6b6:	44 1f       	adc	r20, r20
 6b8:	55 1f       	adc	r21, r21
 6ba:	66 1f       	adc	r22, r22
 6bc:	77 1f       	adc	r23, r23
 6be:	88 1f       	adc	r24, r24
 6c0:	99 1f       	adc	r25, r25
 6c2:	9a 94       	dec	r9
 6c4:	21 f7       	brne	.-56     	; 0x68e <__muldi3+0x12>
 6c6:	9d 01       	movw	r18, r26
 6c8:	ae 01       	movw	r20, r28
 6ca:	bf 01       	movw	r22, r30
 6cc:	c0 01       	movw	r24, r0
 6ce:	11 24       	eor	r1, r1
 6d0:	9f 90       	pop	r9
 6d2:	cf 91       	pop	r28
 6d4:	df 91       	pop	r29
 6d6:	08 95       	ret

000006d8 <_exit>:
 6d8:	f8 94       	cli

000006da <__stop_program>:
 6da:	ff cf       	rjmp	.-2      	; 0x6da <__stop_program>
